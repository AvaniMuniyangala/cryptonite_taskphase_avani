# Cryptography 
## Numbers 
Challenge was exactly as expected.
It was a simple number to alaphabet mapping.
```
picoCTF{THENUMBERSMASON}
```
## miniRSA
Note: <br>
An RSA user creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decrypted by someone who knows the private key.<br>
The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the "factoring problem". Breaking RSA encryption is known as the RSA problem.
<br>
How to encrypt and decrypt rsa <br>
1. Pick two primes: Choose p = 61 and q = 53 <br>
2. Calculate n: n = p × q = 61 × 53 = 3233 <br> 
3. Calculate Carmichael’s Totient λ(n): λ(n) = lcm(60, 52) = 780  <br>
4. Choose e: Pick e = 17 (e should be coprime with 780) <br>
5. Find d: d is the modular inverse of e mod 780, so d = 413  <br>
6. Create the public key: Public key: (n = 3233, e = 17) <br><br>
 m=65<br>
   Encrypt: c = 65^17 mod 3233 = 2790  <br>
   Decrypt: m = 2790^413 mod 3233 = 65<br>
So in this challenge, ```m^e mod n = c``` so ```m^e=xn+c``` which can also be written as
```m = (x * n + c)^(1/e)```
After looking at various other codes for rsa:
```
import gmpy2
n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808145893251774383242888588567652079502880522005531571120463301333725071534050137246298274874319432561063978068140428652193294702808687000503934999928337234367205234422580586283326017530708854836817980318398277272759022724136418545105867685463283579824831916699431331460258806680372323026200534791012439563034432826050072742892112790177234284090476467119938191076883854821999876464545771711445501514467804193760659882386680300508589975451301720477703627085437101600726487172968870448635983769708507451946168500510817590720157574816563284526466526806699820426206566718022595284382939272542309819250701217431454132436646725890151031992160610219312035760562959174778547776304922277751548955049884940378
for x in range(10000):
    trial = x * n + c
    # Calculate the e-th root of the candidate
    m = gmpy2.iroot(trial, e)[0]

    # Check if m raised to e reconstructs the candidate
    if pow(m, e) == trial:
        print(f"x = {x}")
        print(f"Message m: {m}")
        break
```
```
x = 3533
Message m: 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073699800384973262142189949
```
Using the ode from CRYPTOHACK website to convert:
```
!pip install pycryptodome
from Crypto.Util.number import bytes_to_long
from Crypto.Util.number import long_to_bytes

data = 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073700700745451895920079741

bytes = long_to_bytes(data)
print(bytes)
```
The flag 
``` picoCTF{e_sh0u1d_b3_lArg3r_a166c1e3}' ```
which was wrong.
I dont know how to fix it.



